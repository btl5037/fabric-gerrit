<strong>Project</strong>: fabric<br><strong>Branch</strong>: master<br><strong>ID</strong>: 4997<br><strong>Subject</strong>: WIP - Channel Configuration - Feedback only<br><strong>Status</strong>: ABANDONED<br><strong>Owner</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>Assignee</strong>:<br><strong>Created</strong>: 1/29/2017, 1:14:23 PM<br><strong>LastUpdated</strong>: 2/21/2017, 9:30:37 AM<br><strong>CommitMessage</strong>:<br><pre>WIP - Channel Configuration - Feedback only

This CR proposes a new interface for specifying and updating channel
configuration information.  It retains many of the same semantics, but
adds a simple notion of MVCC, and allows configuration items to have
multiplicity.

Change-Id: I5d86643cd94a5269322256834745d368dc721809
Signed-off-by: Jason Yellick <jyellick@us.ibm.com>
</pre><h1>Comments</h1><strong>Reviewer</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>Reviewed</strong>: 1/29/2017, 1:14:23 PM<br><strong>Message</strong>: <pre>Uploaded patch set 1.</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 1/29/2017, 1:18:48 PM<br><strong>Message</strong>: <pre>Patch Set 1:

Build Started https://jenkins.hyperledger.org/job/fabric-verify-x86_64/5890/</pre><strong>Reviewer</strong>: Angelo De Caro - adc@zurich.ibm.com<br><strong>Reviewed</strong>: 1/29/2017, 2:05:47 PM<br><strong>Message</strong>: <pre>Patch Set 1:

(4 comments)</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 1/29/2017, 2:05:57 PM<br><strong>Message</strong>: <pre>Patch Set 1: Verified+1

Build Successful 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/5890/ : SUCCESS</pre><strong>Reviewer</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>Reviewed</strong>: 1/29/2017, 3:20:17 PM<br><strong>Message</strong>: <pre>Patch Set 1:

(4 comments)</pre><strong>Reviewer</strong>: Elli Androulaki - lli@zurich.ibm.com<br><strong>Reviewed</strong>: 1/30/2017, 5:38:19 AM<br><strong>Message</strong>: <pre>Patch Set 1:

(9 comments)

Hi, 

Thanks Jason! I have a couple of questions there :)

With kind regards,
Elli</pre><strong>Reviewer</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>Reviewed</strong>: 1/30/2017, 9:17:39 AM<br><strong>Message</strong>: <pre>Patch Set 1:

(8 comments)</pre><strong>Reviewer</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>Reviewed</strong>: 1/30/2017, 10:39:50 AM<br><strong>Message</strong>: <pre>Patch Set 1:

(1 comment)</pre><strong>Reviewer</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>Reviewed</strong>: 1/31/2017, 10:48:42 PM<br><strong>Message</strong>: <pre>Uploaded patch set 2.</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 1/31/2017, 10:53:13 PM<br><strong>Message</strong>: <pre>Patch Set 2:

Build Started https://jenkins.hyperledger.org/job/fabric-verify-x86_64/6069/</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 2/1/2017, 12:03:59 AM<br><strong>Message</strong>: <pre>Patch Set 2: Verified+1

Build Successful 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/6069/ : SUCCESS</pre><strong>Reviewer</strong>: Elli Androulaki - lli@zurich.ibm.com<br><strong>Reviewed</strong>: 2/6/2017, 11:06:49 AM<br><strong>Message</strong>: <pre>Patch Set 2:

(5 comments)</pre><strong>Reviewer</strong>: Gari Singh - gari.r.singh@gmail.com<br><strong>Reviewed</strong>: 2/6/2017, 1:48:31 PM<br><strong>Message</strong>: <pre>Patch Set 2:

(1 comment)</pre><strong>Reviewer</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>Reviewed</strong>: 2/21/2017, 9:30:37 AM<br><strong>Message</strong>: <pre>Abandoned</pre><h1>PatchSets</h1><h3>PatchSet Number: 1</h3><blockquote><strong>Type</strong>: REWORK<br><strong>Author</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>Uploader</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>Created</strong>: 1/29/2017, 1:14:23 PM<br><strong>UnmergedRevision</strong>: [1d63f3dcfc02f28ed71a8638c97a0e94f738a453](https://github.com/hyperledger-gerrit-archive/fabric/commit/1d63f3dcfc02f28ed71a8638c97a0e94f738a453)<br><br><strong>Approver</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Approved</strong>: 1/29/2017, 2:05:57 PM<br><strong>Type</strong>: Verified<br><strong>Value</strong>: 1<br><br><h2>Comments</h2><strong>Commenter</strong>: Angelo De Caro - adc@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L29](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L29)<br><strong>Comment</strong>: <pre>Something missing here?</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L29](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L29)<br><strong>Comment</strong>: <pre>Will patch in a later changeset, but "no way to allow subsets of policies to have independent modification policies</pre><strong>Commenter</strong>: Angelo De Caro - adc@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L55](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L55)<br><strong>Comment</strong>: <pre>May you also clarify which are supposed to be the readers and writers policy of the channel? I'm asking because I'm a little bit confused by the indirections :(</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L55](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L55)<br><strong>Comment</strong>: <pre>So the idea is, that usually, for GroupConfig, for instance, the reader policy, will be the union of the reader policies for the groups.  So, the reader policy at the channel level would be the union of the reader policies of the Peer and Orderer levels.  Then, at the peer, it would be the union of the reader policy for each peer org, and at the orderer it would be the union of the reader policy for each orderer org.

Of course for admin, you might not use union, you might use intersection, majority, etc.</pre><strong>Commenter</strong>: Elli Androulaki - lli@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L55](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L55)<br><strong>Comment</strong>: <pre>So, what would constitute the reader policy on a per peer level?

Is this motivated by the gossip authentication mechanisms in cases of organization scoped messages? If so, this would be part of the content of global chain or identity chain correct? 

Wouldn't we need to have at least one peer reader policy per organization (if not per organization unit)? Cause I assume different organizations may have different rules of where their peers propagate their messages..</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L55](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L55)<br><strong>Comment</strong>: <pre>So the reader policy at the peer level would be channel_config.groups["Peer"].policies["Reader"].  Note that this is scoped within peer, so for instance, the orderer MSPs do not get read access at the peer.</pre><strong>Commenter</strong>: Elli Androulaki - lli@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L60](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L60)<br><strong>Comment</strong>: <pre>Is there an "indirection" policy type?</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L60](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L60)<br><strong>Comment</strong>: <pre>This certainly could have been clearer.  Here, I'm using the shorthand 'groups.Readers' for 'The union of the Readers policies from each of the entries in groups.  In reality, this would be a new policy type which can only reference policies, in a subgroup.</pre><strong>Commenter</strong>: Elli Androulaki - lli@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L95](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L95)<br><strong>Comment</strong>: <pre>Why do policies need to be repeated here?</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L95](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L95)<br><strong>Comment</strong>: <pre>So these are the policies at the orderer, not at the peer.  Note, that "Admin" is defined without prefix, but you do not want peer administrators to be able to perform orderer administrative actions, and vice versa.

So, for deciding which transactions can enter for ordering, the orderer would look at channel_config.policies["Writers"], but, for deciding which transactions can make it onto the ordering system channel, the orderer would look at channel_config.groups["Orderer"].policies["Writers"].  In the former case, this specifies all Writers from all orgs.  In the latter, only Writers from Orderer orgs.</pre><strong>Commenter</strong>: Elli Androulaki - lli@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L287](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L287)<br><strong>Comment</strong>: <pre>Is it a marshalled GroupConfig (as the comment says) or a ChannelConfig?</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L287](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L287)<br><strong>Comment</strong>: <pre>Ah, ChannelConfig, which is very much like a GroupConfig, just with MSP definitions as well.</pre><strong>Commenter</strong>: Angelo De Caro - adc@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L300](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L300)<br><strong>Comment</strong>: <pre>type missing?</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L300](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L300)<br><strong>Comment</strong>: <pre>Yep, you can tell I didn't compile these, both should be type ChannelConfig</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L300](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L300)<br><strong>Comment</strong>: <pre>Actually, one is a ChannelConfig, the other is a ConfigUpdate, will update.</pre><strong>Commenter</strong>: Elli Androulaki - lli@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L306](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L306)<br><strong>Comment</strong>: <pre>Is this a reference to one of the policies defined in the policies map?</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L306](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L306)<br><strong>Comment</strong>: <pre>Correct, policies are scoped to the GroupItem, so, all mod_policies tied to say channel_config.groups["Orderer"], including channel_config.groups["Orderer].values[*] would come from channel_config.groups["Orderer"].policies.</pre><strong>Commenter</strong>: Elli Androulaki - lli@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L310](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L310)<br><strong>Comment</strong>: <pre>Hm is this MSPs or MSPPrincipals?</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L310](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L310)<br><strong>Comment</strong>: <pre>This is actually MSPs, perhaps identities is the wrong word here? My instinct is to say msps, but, I know that will look gross in golang once compiled (Msps)</pre><strong>Commenter</strong>: Angelo De Caro - adc@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L316](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L316)<br><strong>Comment</strong>: <pre>MSPConfig?</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L316](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L316)<br><strong>Comment</strong>: <pre>Could be, whatever structure it is that defines a single MSP within the MSP manager, will look this up and do the import before submitting for real.</pre><strong>Commenter</strong>: Elli Androulaki - lli@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L316](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L316)<br><strong>Comment</strong>: <pre>Yes, this  is MSPConfig :)</pre><strong>Commenter</strong>: Elli Androulaki - lli@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L324](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L324)<br><strong>Comment</strong>: <pre>So, can you give an example of what GroupConfig could include from the config items of the current configuration scheme? E.g., can it be that it contains all orderer-specific information whose change requires orderer.admin to order their modification?</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L324](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L324)<br><strong>Comment</strong>: <pre>I think this is expressed in the examples at the beginning.  Can you maybe be more specific?</pre><strong>Commenter</strong>: Elli Androulaki - lli@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L327](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L327)<br><strong>Comment</strong>: <pre>How can one define these policies without a reference to an MSP/MSPPrincipal? Are these policies referencing the inherited MSPconfiguration?</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L327](https://github.com/hyperledger-gerrit-archive/fabric/blob/1d63f3dcfc02f28ed71a8638c97a0e94f738a453/protos/common/new_configuration.proto#L327)<br><strong>Comment</strong>: <pre>Leaf policies encode MSPPrincipals, which are evaluated using the top level MSPs.  Node policies usually only reference leaf policies, but could reference MSPPrincipals as well.</pre></blockquote><h3>PatchSet Number: 2</h3><blockquote><strong>Type</strong>: REWORK<br><strong>Author</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>Uploader</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>Created</strong>: 1/31/2017, 10:48:42 PM<br><strong>UnmergedRevision</strong>: [ed4f90179e1604d012d21b99ff1723dbb9eb6838](https://github.com/hyperledger-gerrit-archive/fabric/commit/ed4f90179e1604d012d21b99ff1723dbb9eb6838)<br><br><strong>Approver</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Approved</strong>: 2/1/2017, 12:03:59 AM<br><strong>Type</strong>: Verified<br><strong>Value</strong>: 1<br><br><h2>Comments</h2><strong>Commenter</strong>: Elli Androulaki - lli@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L247](https://github.com/hyperledger-gerrit-archive/fabric/blob/ed4f90179e1604d012d21b99ff1723dbb9eb6838/protos/common/new_configuration.proto#L247)<br><strong>Comment</strong>: <pre>This should be an MSPValue type, no?</pre><strong>Commenter</strong>: Elli Androulaki - lli@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L251](https://github.com/hyperledger-gerrit-archive/fabric/blob/ed4f90179e1604d012d21b99ff1723dbb9eb6838/protos/common/new_configuration.proto#L251)<br><strong>Comment</strong>: <pre>Isn't this MSPValue?</pre><strong>Commenter</strong>: Elli Androulaki - lli@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L255](https://github.com/hyperledger-gerrit-archive/fabric/blob/ed4f90179e1604d012d21b99ff1723dbb9eb6838/protos/common/new_configuration.proto#L255)<br><strong>Comment</strong>: <pre>Same as before.</pre><strong>Commenter</strong>: Elli Androulaki - lli@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L259](https://github.com/hyperledger-gerrit-archive/fabric/blob/ed4f90179e1604d012d21b99ff1723dbb9eb6838/protos/common/new_configuration.proto#L259)<br><strong>Comment</strong>: <pre>Same as before.</pre><strong>Commenter</strong>: Elli Androulaki - lli@zurich.ibm.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L334](https://github.com/hyperledger-gerrit-archive/fabric/blob/ed4f90179e1604d012d21b99ff1723dbb9eb6838/protos/common/new_configuration.proto#L334)<br><strong>Comment</strong>: <pre>Let me try to confirm the flow. So, say identity channel idc has included block bidc5, and an application channel appc is to be "informed" about it with a ConfigResult. This is done by wrapping a configResult object within a Configuration Envelope (?). And the ConfigResult, would have as channel_config the resulting configuration of appc after the change suggested in generating_update is applied to appc's current configuration (?)</pre><strong>Commenter</strong>: Gari Singh - gari.r.singh@gmail.com<br><strong>CommentLine</strong>: [protos/common/new_configuration.proto#L343](https://github.com/hyperledger-gerrit-archive/fabric/blob/ed4f90179e1604d012d21b99ff1723dbb9eb6838/protos/common/new_configuration.proto#L343)<br><strong>Comment</strong>: <pre>I understand doing this for extensibility, but shouldn't we explicitly have fields for the groups we know we want / need - Orderer and Peer?  And do we really want people to be able to add their own types of groupconfigs?</pre></blockquote>