<strong>Project</strong>: fabric<br><strong>Branch</strong>: master<br><strong>ID</strong>: 483<br><strong>Subject</strong>: Protocol buffer messages associated with the next architecture<br><strong>Status</strong>: ABANDONED<br><strong>Owner</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>Assignee</strong>:<br><strong>Created</strong>: 8/11/2016, 11:09:07 AM<br><strong>LastUpdated</strong>: 9/21/2016, 7:03:44 AM<br><strong>CommitMessage</strong>:<br><pre>Protocol buffer messages associated with the next architecture

This change includes a new fabric.proto file that defines
messages between the SDK, endorsers, ordering service, and
committers. These messages are required by the next architecture.
The messages have been derived from the Hyperledger Protocol
Working Group and many others working on the next architecture.
This API is not the final form, but a proposed start that
can be used and evolved as the new components are built.

Change-Id: Iff6316a5d9540c5ce34bb1fe43a78d1d9deb2012
Signed-off-by: Sheehan Anderson <sheehan@us.ibm.com>
</pre><h1>Comments</h1><strong>Reviewer</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>Reviewed</strong>: 8/11/2016, 11:09:07 AM<br><strong>Message</strong>: <pre>Uploaded patch set 1.</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 8/11/2016, 11:16:05 AM<br><strong>Message</strong>: <pre>Patch Set 1:

Build Started https://jenkins.hyperledger.org/job/fabric-verify-x86_64/301/</pre><strong>Reviewer</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>Reviewed</strong>: 8/11/2016, 11:22:46 AM<br><strong>Message</strong>: <pre>Uploaded patch set 2.</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 8/11/2016, 11:27:29 AM<br><strong>Message</strong>: <pre>Patch Set 2:

Build Started https://jenkins.hyperledger.org/job/fabric-verify-x86_64/302/</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 8/11/2016, 11:31:51 AM<br><strong>Message</strong>: <pre>Patch Set 1: Verified-1

Build Failed 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/301/ : FAILURE</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 8/11/2016, 11:52:31 AM<br><strong>Message</strong>: <pre>Patch Set 2: Verified-1

Build Failed 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/302/ : FAILURE</pre><strong>Reviewer</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>Reviewed</strong>: 8/12/2016, 11:22:03 AM<br><strong>Message</strong>: <pre>Uploaded patch set 3.</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 8/12/2016, 11:24:54 AM<br><strong>Message</strong>: <pre>Patch Set 3:

Build Started https://jenkins.hyperledger.org/job/fabric-verify-x86_64/324/</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 8/12/2016, 12:01:14 PM<br><strong>Message</strong>: <pre>Patch Set 3: Verified-1

Build Failed 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/324/ : FAILURE</pre><strong>Reviewer</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>Reviewed</strong>: 8/12/2016, 1:55:48 PM<br><strong>Message</strong>: <pre>Uploaded patch set 4.</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 8/12/2016, 1:58:32 PM<br><strong>Message</strong>: <pre>Patch Set 4:

Build Started https://jenkins.hyperledger.org/job/fabric-verify-x86_64/326/</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 8/12/2016, 2:27:10 PM<br><strong>Message</strong>: <pre>Patch Set 4: Verified-1

Build Failed 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/326/ : FAILURE</pre><strong>Reviewer</strong>: Gabor Hosszu - gabor@digitalasset.com<br><strong>Reviewed</strong>: 8/15/2016, 4:12:43 AM<br><strong>Message</strong>: <pre>Patch Set 4:

(1 comment)</pre><strong>Reviewer</strong>: Greg Haskins - gregory.haskins@gmail.com<br><strong>Reviewed</strong>: 8/15/2016, 8:44:33 AM<br><strong>Message</strong>: <pre>Patch Set 4:

(1 comment)</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 8/15/2016, 10:12:32 AM<br><strong>Message</strong>: <pre>Patch Set 4:

(1 comment)</pre><strong>Reviewer</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>Reviewed</strong>: 8/15/2016, 11:17:55 AM<br><strong>Message</strong>: <pre>Patch Set 4:

(1 comment)</pre><strong>Reviewer</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>Reviewed</strong>: 8/15/2016, 11:21:38 AM<br><strong>Message</strong>: <pre>Patch Set 4:

(1 comment)</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 8/15/2016, 11:48:25 AM<br><strong>Message</strong>: <pre>Patch Set 4:

(1 comment)</pre><strong>Reviewer</strong>: Gabor Hosszu - gabor@digitalasset.com<br><strong>Reviewed</strong>: 8/16/2016, 3:21:33 AM<br><strong>Message</strong>: <pre>Patch Set 4:

(1 comment)</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 8/16/2016, 7:57:06 PM<br><strong>Message</strong>: <pre>Patch Set 4: -Verified

Build Started https://jenkins.hyperledger.org/job/fabric-verify-x86_64/365/</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 8/16/2016, 8:30:08 PM<br><strong>Message</strong>: <pre>Patch Set 4: Verified-1

Build Failed 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/365/ : FAILURE</pre><strong>Reviewer</strong>: Simon Schubert - 2-hl-gerrit@0x2c.org<br><strong>Reviewed</strong>: 8/17/2016, 7:40:33 AM<br><strong>Message</strong>: <pre>Patch Set 4:

(9 comments)</pre><strong>Reviewer</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>Reviewed</strong>: 8/17/2016, 10:13:07 AM<br><strong>Message</strong>: <pre>Patch Set 4:

(9 comments)</pre><strong>Reviewer</strong>: Jeffery Garratt - garratt.jeff@gmail.com<br><strong>Reviewed</strong>: 8/17/2016, 10:22:38 AM<br><strong>Message</strong>: <pre>Patch Set 4:

> (9 comments)

The oneof vs type would introduce the issue of serialization and hashing.  By using type with bytes the hash/signature can be verified.</pre><strong>Reviewer</strong>: Manish Sethi - manish.sethi@gmail.com<br><strong>Reviewed</strong>: 8/17/2016, 2:20:35 PM<br><strong>Message</strong>: <pre>Patch Set 4:

(1 comment)</pre><strong>Reviewer</strong>: Kostas Christidis - kostas@gmail.com<br><strong>Reviewed</strong>: 8/17/2016, 3:43:35 PM<br><strong>Message</strong>: <pre>Patch Set 4:

(1 comment)

Note on deterministic (de-)serialization.</pre><strong>Reviewer</strong>: Simon Schubert - 2-hl-gerrit@0x2c.org<br><strong>Reviewed</strong>: 8/17/2016, 5:04:02 PM<br><strong>Message</strong>: <pre>Patch Set 4:

type needs to be part of the hash.  I don't see why oneof would lead to problems during serialization.</pre><strong>Reviewer</strong>: Baohua Yang - yangbaohua@gmail.com<br><strong>Reviewed</strong>: 8/17/2016, 10:53:15 PM<br><strong>Message</strong>: <pre>Patch Set 4:

(3 comments)

See comments in line.
thanks!</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 8/20/2016, 3:58:48 PM<br><strong>Message</strong>: <pre>Patch Set 4: -Verified

Build Started https://jenkins.hyperledger.org/job/fabric-verify-x86_64/472/</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 8/20/2016, 4:31:08 PM<br><strong>Message</strong>: <pre>Patch Set 4: Verified-1

Build Failed 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/472/ : FAILURE</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 8/21/2016, 2:52:51 PM<br><strong>Message</strong>: <pre>Patch Set 4: -Verified

Build Started https://jenkins.hyperledger.org/job/fabric-verify-x86_64/482/</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 8/21/2016, 3:38:42 PM<br><strong>Message</strong>: <pre>Patch Set 4: Verified-1

Build Failed 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/482/ : FAILURE</pre><strong>Reviewer</strong>: Bishop Brock - bcbrock@us.ibm.com<br><strong>Reviewed</strong>: 8/23/2016, 5:48:49 PM<br><strong>Message</strong>: <pre>Patch Set 4:

(1 comment)</pre><strong>Reviewer</strong>: Bishop Brock - bcbrock@us.ibm.com<br><strong>Reviewed</strong>: 8/23/2016, 7:08:04 PM<br><strong>Message</strong>: <pre>Patch Set 4:

(2 comments)</pre><strong>Reviewer</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>Reviewed</strong>: 8/24/2016, 1:17:11 PM<br><strong>Message</strong>: <pre>Patch Set 4: Cherry Picked

This patchset was cherry picked to branch feature/convergence as commit 70afd302ea5fa37e38e23b3e763a2b7f4d462562</pre><strong>Reviewer</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>Reviewed</strong>: 8/25/2016, 4:56:18 PM<br><strong>Message</strong>: <pre>Patch Set 4:

(1 comment)</pre><strong>Reviewer</strong>: Christopher Ferris - chris.ferris@gmail.com<br><strong>Reviewed</strong>: 8/25/2016, 5:37:31 PM<br><strong>Message</strong>: <pre>Patch Set 4: Code-Review-1

needs tests for the generated api</pre><strong>Reviewer</strong>: Christopher Ferris - chris.ferris@gmail.com<br><strong>Reviewed</strong>: 9/2/2016, 6:52:46 PM<br><strong>Message</strong>: <pre>Patch Set 4:

> Build Failed
 > 
 > https://jenkins.hyperledger.org/job/fabric-verify-x86_64/482/ :
 > FAILURE

reverify</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 9/2/2016, 8:06:07 PM<br><strong>Message</strong>: <pre>Patch Set 4: -Verified

Build Started https://jenkins.hyperledger.org/job/fabric-verify-x86_64/892/</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 9/2/2016, 8:36:27 PM<br><strong>Message</strong>: <pre>Patch Set 4: Verified-1

Build Failed 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/892/ : FAILURE</pre><strong>Reviewer</strong>: Christopher Ferris - chris.ferris@gmail.com<br><strong>Reviewed</strong>: 9/15/2016, 3:58:41 PM<br><strong>Message</strong>: <pre>Patch Set 4:

> Build Failed
 > 
 > https://jenkins.hyperledger.org/job/fabric-verify-x86_64/892/ :
 > FAILURE

reverify</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 9/15/2016, 4:04:28 PM<br><strong>Message</strong>: <pre>Patch Set 4: -Verified

Build Started https://jenkins.hyperledger.org/job/fabric-verify-behave-x86_64/116/ (2/2)</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 9/15/2016, 4:51:56 PM<br><strong>Message</strong>: <pre>Patch Set 4: Verified-1

Build Failed 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/1193/ : FAILURE

https://jenkins.hyperledger.org/job/fabric-verify-behave-x86_64/116/ : SUCCESS (skipped)</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 9/18/2016, 7:18:03 PM<br><strong>Message</strong>: <pre>Patch Set 4: Code-Review-2

This can be abandoned now that it has been absorbed into the convergence branch.</pre><strong>Reviewer</strong>: Christopher Ferris - chris.ferris@gmail.com<br><strong>Reviewed</strong>: 9/21/2016, 7:03:44 AM<br><strong>Message</strong>: <pre>Abandoned

see Murali's comment</pre><h1>PatchSets</h1><h3>PatchSet Number: 1</h3><blockquote><strong>Type</strong>: REWORK<br><strong>Author</strong>: sheehan - sheehan@us.ibm.com<br><strong>Uploader</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>Created</strong>: 8/11/2016, 11:09:07 AM<br><strong>UnmergedRevision</strong>: [003b9714b720f88f6db8a130ce3d77bf6793c9a0](https://github.com/hyperledger-gerrit-archive/fabric/commit/003b9714b720f88f6db8a130ce3d77bf6793c9a0)<br><br><strong>Approver</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Approved</strong>: 8/11/2016, 11:31:51 AM<br><strong>Type</strong>: Verified<br><strong>Value</strong>: -1<br><br></blockquote><h3>PatchSet Number: 2</h3><blockquote><strong>Type</strong>: REWORK<br><strong>Author</strong>: sheehan - sheehan@us.ibm.com<br><strong>Uploader</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>Created</strong>: 8/11/2016, 11:22:46 AM<br><strong>UnmergedRevision</strong>: [5bdaf237975cd89f539cc349e62cef6d192fdac8](https://github.com/hyperledger-gerrit-archive/fabric/commit/5bdaf237975cd89f539cc349e62cef6d192fdac8)<br><br><strong>Approver</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Approved</strong>: 8/11/2016, 11:52:31 AM<br><strong>Type</strong>: Verified<br><strong>Value</strong>: -1<br><br></blockquote><h3>PatchSet Number: 3</h3><blockquote><strong>Type</strong>: REWORK<br><strong>Author</strong>: sheehan - sheehan@us.ibm.com<br><strong>Uploader</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>Created</strong>: 8/12/2016, 11:22:03 AM<br><strong>UnmergedRevision</strong>: [31fec04d67d0c19530d41dcaf6905e6da781dee0](https://github.com/hyperledger-gerrit-archive/fabric/commit/31fec04d67d0c19530d41dcaf6905e6da781dee0)<br><br><strong>Approver</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Approved</strong>: 8/12/2016, 12:01:14 PM<br><strong>Type</strong>: Verified<br><strong>Value</strong>: -1<br><br></blockquote><h3>PatchSet Number: 4</h3><blockquote><strong>Type</strong>: REWORK<br><strong>Author</strong>: sheehan - sheehan@us.ibm.com<br><strong>Uploader</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>Created</strong>: 8/12/2016, 1:55:48 PM<br><strong>UnmergedRevision</strong>: [5c5439337a89e26fc8348a29af3024722165a9e2](https://github.com/hyperledger-gerrit-archive/fabric/commit/5c5439337a89e26fc8348a29af3024722165a9e2)<br><br><strong>Approver</strong>: Christopher Ferris - chris.ferris@gmail.com<br><strong>Approved</strong>: 8/25/2016, 5:37:31 PM<br><strong>Type</strong>: Code-Review<br><strong>Value</strong>: -1<br><br><strong>Approver</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Approved</strong>: 9/15/2016, 4:51:56 PM<br><strong>Type</strong>: Verified<br><strong>Value</strong>: -1<br><br><strong>Approver</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Approved</strong>: 9/18/2016, 7:18:03 PM<br><strong>Type</strong>: Code-Review<br><strong>Value</strong>: -1<br><br><h2>Comments</h2><strong>Commenter</strong>: Gabor Hosszu - gabor@digitalasset.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.pb.go#L1](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.pb.go#L1)<br><strong>Comment</strong>: <pre>Just as a comment: I do not understand why we upload generated sources like this. Isn't it better to run proto generation for every build?</pre><strong>Commenter</strong>: Greg Haskins - gregory.haskins@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.pb.go#L1](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.pb.go#L1)<br><strong>Comment</strong>: <pre>In the early days of the project, there was no Makefile and no great solution to do anything BUT check these in.  Now that we have a makefile, we certainly could do this but I am a little torn as to what may be the ideal timing.  To date, the proto3 stuff was alpha/beta and thus rapidly changing so one could make an argument that checking in the result is probably a more reliable mechanism.  If this has finally stabilized, we could consider making the artifacts dynamic.</pre><strong>Commenter</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.pb.go#L1](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.pb.go#L1)<br><strong>Comment</strong>: <pre>Protobuf 3.0.0 has been released https://github.com/google/protobuf/releases/tag/v3.0.0

Agree that we should upgrade to 3.0.0 before considering dynamic proto generation.</pre><strong>Commenter</strong>: Baohua Yang - yangbaohua@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.pb.go#L1](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.pb.go#L1)<br><strong>Comment</strong>: <pre>+1 on 3.0.
And need to provide a unique env/method to use protoc.</pre><strong>Commenter</strong>: Simon Schubert - 2-hl-gerrit@0x2c.org<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L60](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L60)<br><strong>Comment</strong>: <pre>I think you mean serialization is not necessarily deterministic?  At least not a clear project goal to always serialize in the same way.</pre><strong>Commenter</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L60](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L60)<br><strong>Comment</strong>: <pre>I've never seen it stated as a clear goal either. However, Jeff told me he has seen documentation that states it is. I will ask for the doc and link in the comments. If we can't find the info, it's another reason not to use protobuf for anything written to disk.</pre><strong>Commenter</strong>: Kostas Christidis - kostas@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L60](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L60)<br><strong>Comment</strong>: <pre>Right, the original statement should be amended. In fact, according to the v3.0.0 release notes the only proper statement is that "deterministic serialization is not canonical across languages." (This is the reason why: https://news.ycombinator.com/item?id=12188422)</pre><strong>Commenter</strong>: Simon Schubert - 2-hl-gerrit@0x2c.org<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L75](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L75)<br><strong>Comment</strong>: <pre>Why is the message type not part of the signed data?</pre><strong>Commenter</strong>: Simon Schubert - 2-hl-gerrit@0x2c.org<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L82](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L82)<br><strong>Comment</strong>: <pre>Why do we use enum + payload instead of oneof?</pre><strong>Commenter</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L82](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L82)<br><strong>Comment</strong>: <pre>This is a good suggestion and I think oneof may make the proto more clear. I'll ask Jeff to respond to see if he has any reasons to stick with this format.</pre><strong>Commenter</strong>: Baohua Yang - yangbaohua@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L82](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L82)<br><strong>Comment</strong>: <pre>They are for different scenarios.
Typically, enum is for one field with fixed-ranged values.
While oneof is for different fields, but can only keep one at each time.
I guess the enum if more explicit for this Type case: a field with multiple value choices.</pre><strong>Commenter</strong>: Simon Schubert - 2-hl-gerrit@0x2c.org<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L153](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L153)<br><strong>Comment</strong>: <pre>I don't think HTTP status codes make any sense.  What would 301 even mean?</pre><strong>Commenter</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L153](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L153)<br><strong>Comment</strong>: <pre>301 = "don't ask me for endorsements anymore, ask this endorser"?

Ok, I agree it's a bit hokey :) We want some way for the Endorser to give the SDK/Client a response. Is there some other standard response format we could follow? We could always invent our own, but I'd rather not if possible.</pre><strong>Commenter</strong>: Baohua Yang - yangbaohua@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L153](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L153)<br><strong>Comment</strong>: <pre>+1. No relying on HTTP status code directly, from bloody experience :)</pre><strong>Commenter</strong>: Simon Schubert - 2-hl-gerrit@0x2c.org<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L174](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L174)<br><strong>Comment</strong>: <pre>Who creates this?  Who receives and acts upon this?</pre><strong>Commenter</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L174](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L174)<br><strong>Comment</strong>: <pre>This is created by the Endorser. The committer modified the ledger based on the Action.</pre><strong>Commenter</strong>: Simon Schubert - 2-hl-gerrit@0x2c.org<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L184](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L184)<br><strong>Comment</strong>: <pre>where is this defined?</pre><strong>Commenter</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L184](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L184)<br><strong>Comment</strong>: <pre>This is not yet defined. I believe Manish was in favor initially as leaving this as bytes to provide flexibility in the API. Different ledger implementations could theoretically define what the simulation result looked like.

There are of course lots of benefits to defining a standard also. I will ask Manish to respond with his current thoughts.</pre><strong>Commenter</strong>: Manish Sethi - manish.sethi@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L184](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L184)<br><strong>Comment</strong>: <pre>As Sheehan summarized - the idea behind leaving this as bytes is to allow variations in the ledger implementations.

A ledger that exposes a relational data model may represent the read-write set differently (for instance, it may wrap all changes to a table under a table name for a concise representation) than a ledger that exposes a KV data model. Similarly, there was a discussion on a possibility of allowing different representation for the versioning info in the read-write set (https://github.com/hyperledger/fabric/issues/1631#issuecomment-231040960).

Since, the simulation results are both produced and consumed by ledger only and are opaque to other component so it's better to leave it flexible.</pre><strong>Commenter</strong>: Bishop Brock - bcbrock@us.ibm.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L184](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L184)<br><strong>Comment</strong>: <pre>if this field is completely flexible, then the field name is potentially misleading. For example, this field may contain representations of commutative operations that are not actually "simulated", such as  "add 100 to the value of account A". Also, since the Endorsing and Validating System Chaincodes are parameters, then there is no requirement for this to be simulation result at all - it can contain arbitrary data, and this framework can be just as well be used to implement agreement-before-execution systems like the current Hyperledger fabric. A better name for this field might simply be "action".</pre><strong>Commenter</strong>: Simon Schubert - 2-hl-gerrit@0x2c.org<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L190](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L190)<br><strong>Comment</strong>: <pre>are events something like generic metadata that are extracted and used by ledger consumers?</pre><strong>Commenter</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L190](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L190)<br><strong>Comment</strong>: <pre>I assume an Event will eventually have a standard definition. I tried using the existing events.proto, but that depended on the existing Transaction which broke things so I left it as bytes for now.</pre><strong>Commenter</strong>: Simon Schubert - 2-hl-gerrit@0x2c.org<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L195](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L195)<br><strong>Comment</strong>: <pre>Why is the escc part of the action?  Doesn't the endorser produce the action?</pre><strong>Commenter</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L195](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L195)<br><strong>Comment</strong>: <pre>Yes, the endorser produces the Action. This is just the ID of the ESCC. The use case was that when a Transaction reaches the VSCC, the VSCC potentially needs to know the ESCC that was run against this particular Action.</pre><strong>Commenter</strong>: Bishop Brock - bcbrock@us.ibm.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L195](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L195)<br><strong>Comment</strong>: <pre>Why are the escc and vscc required to be system chaincodes? I can see why it might improve performance, but otherwise it isn't clear why it is necessary.</pre><strong>Commenter</strong>: Bishop Brock - bcbrock@us.ibm.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L195](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L195)<br><strong>Comment</strong>: <pre>If I understand what's going on here, then I would think that the most general definitions of the ESCC and VSCC would include the option of explicit parameters.</pre><strong>Commenter</strong>: Simon Schubert - 2-hl-gerrit@0x2c.org<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L255](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L255)<br><strong>Comment</strong>: <pre>shouldn't we also define a block?  would that then be bytes prevBlockHash; repeated bytes transactionBytes?</pre><strong>Commenter</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L255](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L255)<br><strong>Comment</strong>: <pre>Yes, we should. I didn't define it here because I noticed you had already defined a new block in your new consensus work on GitHub. Should I just copy that one?</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L257](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L257)<br><strong>Comment</strong>: <pre>Don't we need a Transaction ID ? We'd need a handle to query etc ?</pre><strong>Commenter</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L257](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L257)<br><strong>Comment</strong>: <pre>I don't think queries should be submitted as a Transaction. Queries could be returned in the Response Message of a ProposalResponse. We could also consider creating a separate API on committers to handle queries.

If the Transaction ID can be generated deterministically based on the content of a Transaction, I'm not sure why it would be required to be passed from the SDK to the ordering service.

Is there a benefit of passing the Transaction ID that I am missing?</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L257](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L257)<br><strong>Comment</strong>: <pre>Well, don't we have to store the TID<-->Transaction mapping via an index on TID so we can answer "get Transaction given TID" ?

Given the above, the question was could store that TID in the transaction as well ? This is not strictly necessary but has the benefit of keeping the association between Transaction and the TID together (just as "ID" is a key as well as field in an "Employee" table). Also, perhaps it could also be used for validation (is the TID computed by consensus same as that computed by the SDK) ?

Again not strictly necessary but just an exploration...</pre><strong>Commenter</strong>: Gabor Hosszu - gabor@digitalasset.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L257](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L257)<br><strong>Comment</strong>: <pre>As I have already mentioned, my opinion is not to store TxID in TX as it seems unnecessary to me. In the ledger/database, we need it in an index/mapping to be able to answer "get Tx given TxID" type questions, of course.</pre><strong>Commenter</strong>: Sheehan Anderson - sranderson@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L257](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L257)<br><strong>Comment</strong>: <pre>I agree with Gabor. We can have an index of TXID->Transaction, but given the continuous growth of the blockchain, it's best to avoid denormalization and optimize for space.</pre><strong>Commenter</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>CommentLine</strong>: [protos/next/fabric_next.proto#L257](https://github.com/hyperledger-gerrit-archive/fabric/blob/5c5439337a89e26fc8348a29af3024722165a9e2/protos/next/fabric_next.proto#L257)<br><strong>Comment</strong>: <pre>Given the non deterministic nature of serialization discussed above, we need to be careful with the tid calculated on the peer side. The tx might be submitted by languages than Go. Would the payload []byte coming in on the Peer side in Go be exactly the same as the []byte on the client side in Java?  If not, we would end up with 2 different hashes.</pre></blockquote>