<strong>Project</strong>: fabric<br><strong>Branch</strong>: master<br><strong>ID</strong>: 3241<br><strong>Subject</strong>: FAB-1378 beginnings of a join command<br><strong>Status</strong>: MERGED<br><strong>Owner</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Assignee</strong>:<br><strong>Created</strong>: 12/13/2016, 12:59:16 AM<br><strong>LastUpdated</strong>: 12/16/2016, 8:35:29 AM<br><strong>CommitMessage</strong>:<br><pre>FAB-1378 beginnings of a join command

https://jira.hyperledger.org/browse/FAB-1378

"peer node start" works as before and creates the default chain.

"peer node start --peer-defaultchain=false" however starts without
a chain. It just creates the gossip service and starts up the
peer server in a chainless, ledgerless mode. The peer is read to
accept join calls.

"peer node join -b <path to genesis block file>" calls CSCC with
the genesis block.

kvledgers is removed and the peer package is used for ledger access.

CSCC is under construction but this CR allows the work to be driven
via CLI (and later from SDK).

Change-Id: Id581c1f04b8788f54be467f593d74ea6b1efe713
Signed-off-by: Srinivasan Muralidharan <muralisr@us.ibm.com>
</pre><h1>Comments</h1><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 12/13/2016, 12:59:16 AM<br><strong>Message</strong>: <pre>Uploaded patch set 1.</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 12/13/2016, 1:00:28 AM<br><strong>Message</strong>: <pre>Patch Set 1:

Build Started https://jenkins.hyperledger.org/job/fabric-verify-x86_64/3981/</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 12/13/2016, 1:22:56 AM<br><strong>Message</strong>: <pre>Patch Set 1: Verified-1

Build Failed 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/3981/ : FAILURE</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 12/13/2016, 7:51:02 AM<br><strong>Message</strong>: <pre>Uploaded patch set 2.</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 12/13/2016, 7:52:28 AM<br><strong>Message</strong>: <pre>Uploaded patch set 3.</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 12/13/2016, 7:53:19 AM<br><strong>Message</strong>: <pre>Patch Set 2:

Build Started https://jenkins.hyperledger.org/job/fabric-verify-x86_64/3986/</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 12/13/2016, 7:55:47 AM<br><strong>Message</strong>: <pre>Patch Set 3:

Build Started https://jenkins.hyperledger.org/job/fabric-verify-x86_64/3987/</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 12/13/2016, 8:20:50 AM<br><strong>Message</strong>: <pre>Patch Set 3: Verified-1

Build Failed 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/3987/ : FAILURE</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 12/13/2016, 8:27:58 AM<br><strong>Message</strong>: <pre>Patch Set 2: Verified-1

Build Failed 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/3986/ : FAILURE</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 12/13/2016, 9:07:23 PM<br><strong>Message</strong>: <pre>Uploaded patch set 4.</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 12/13/2016, 9:09:42 PM<br><strong>Message</strong>: <pre>Patch Set 4:

Build Started https://jenkins.hyperledger.org/job/fabric-verify-x86_64/4072/</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 12/13/2016, 9:44:43 PM<br><strong>Message</strong>: <pre>Patch Set 4: Verified+1

Build Successful 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/4072/ : SUCCESS</pre><strong>Reviewer</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>Reviewed</strong>: 12/13/2016, 11:40:40 PM<br><strong>Message</strong>: <pre>Patch Set 4: Code-Review-1

(5 comments)

Let chat about chainless thing and address the following comments.</pre><strong>Reviewer</strong>: Alessandro Sorniotti - ale.linux@sopit.net<br><strong>Reviewed</strong>: 12/14/2016, 5:59:36 AM<br><strong>Message</strong>: <pre>Patch Set 4:

(2 comments)

Thanks Murali, I've left you two comments, one linking to my CR that you may consider using.</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 12/14/2016, 1:14:21 PM<br><strong>Message</strong>: <pre>Patch Set 4:

(5 comments)</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 12/15/2016, 2:06:11 AM<br><strong>Message</strong>: <pre>Uploaded patch set 5.</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 12/15/2016, 2:11:38 AM<br><strong>Message</strong>: <pre>Patch Set 5:

Build Started https://jenkins.hyperledger.org/job/fabric-verify-x86_64/4154/</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 12/15/2016, 2:11:38 AM<br><strong>Message</strong>: <pre>Patch Set 4:

(3 comments)</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 12/15/2016, 2:53:13 AM<br><strong>Message</strong>: <pre>Patch Set 5: Verified+1

Build Successful 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/4154/ : SUCCESS</pre><strong>Reviewer</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>Reviewed</strong>: 12/15/2016, 9:51:01 AM<br><strong>Message</strong>: <pre>Patch Set 5: Code-Review+2</pre><strong>Reviewer</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>Reviewed</strong>: 12/15/2016, 10:52:54 AM<br><strong>Message</strong>: <pre>Patch Set 5:

(3 comments)</pre><strong>Reviewer</strong>: Alessandro Sorniotti - ale.linux@sopit.net<br><strong>Reviewed</strong>: 12/15/2016, 11:25:26 AM<br><strong>Message</strong>: <pre>Patch Set 5:

(1 comment)</pre><strong>Reviewer</strong>: Artem Barger - bartem@il.ibm.com<br><strong>Reviewed</strong>: 12/15/2016, 12:16:16 PM<br><strong>Message</strong>: <pre>Patch Set 5:

(4 comments)

Probably missed that part, I was looking where do you call gossip join channel to notify the gossip layer of the peer which has to join the channel. Wasn't able to find it, can you please reference me were are you doing that?</pre><strong>Reviewer</strong>: Christopher Ferris - chris.ferris@gmail.com<br><strong>Reviewed</strong>: 12/15/2016, 1:45:56 PM<br><strong>Message</strong>: <pre>Patch Set 5:

(2 comments)</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 12/15/2016, 2:34:22 PM<br><strong>Message</strong>: <pre>Patch Set 5:

(8 comments)

Please respond to the comments and I'll proceed with an update as necessary.</pre><strong>Reviewer</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>Reviewed</strong>: 12/15/2016, 2:45:56 PM<br><strong>Message</strong>: <pre>Patch Set 5:

(2 comments)</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 12/15/2016, 2:52:15 PM<br><strong>Message</strong>: <pre>Patch Set 5:

> (2 comments)

Actually right now it is. Hence the need for "Chainless" to indicate a chaincode should/can be brought up without a chain context.

However we can also implement it another way. Take an example - the LCCC. We can just bring it up one instance and NOT tie it to a chain. Then all we have to do when a new chain is created is to initialize it on that chain. All invokes to LCCC have a chain (ledger) context anyway so that one instance of that LCCC will serve all chains. Basically one connection channel between the running LCCC and peer as opposed to one per chain.</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 12/15/2016, 2:59:58 PM<br><strong>Message</strong>: <pre>Patch Set 5:

(1 comment)</pre><strong>Reviewer</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>Reviewed</strong>: 12/15/2016, 3:01:08 PM<br><strong>Message</strong>: <pre>Patch Set 5:

> > (2 comments)
 > 
 > Actually right now it is. Hence the need for "Chainless" to
 > indicate a chaincode should/can be brought up without a chain
 > context.
 > 
 > However we can also implement it another way. Take an example - the
 > LCCC. We can just bring it up one instance and NOT tie it to a
 > chain. Then all we have to do when a new chain is created is to
 > initialize it on that chain. All invokes to LCCC have a chain
 > (ledger) context anyway so that one instance of that LCCC will
 > serve all chains. Basically one connection channel between the
 > running LCCC and peer as opposed to one per chain.

Ah, I think I finally get it.  I had assumed that this was a global property for that chaincode, and not a local one for this particular instantiation, but it is actually a local property.  Is that right?</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 12/15/2016, 3:06:19 PM<br><strong>Message</strong>: <pre>Patch Set 5:

> > > (2 comments)
 > >
 > > Actually right now it is. Hence the need for "Chainless" to
 > > indicate a chaincode should/can be brought up without a chain
 > > context.
 > >
 > > However we can also implement it another way. Take an example -
 > the
 > > LCCC. We can just bring it up one instance and NOT tie it to a
 > > chain. Then all we have to do when a new chain is created is to
 > > initialize it on that chain. All invokes to LCCC have a chain
 > > (ledger) context anyway so that one instance of that LCCC will
 > > serve all chains. Basically one connection channel between the
 > > running LCCC and peer as opposed to one per chain.
 > 
 > Ah, I think I finally get it.  I had assumed that this was a global
 > property for that chaincode, and not a local one for this
 > particular instantiation, but it is actually a local property.  Is
 > that right?

You were right the first time :-) but kinda right the second too.... It is "global" property only because I aslo use it to instantiate such objects exatly once (and not per chain as they are chainless). But if we go with the second method of instantiating LCCC, CSCC and others just once but switch the context to use different chains (or no chain/ledger) at invoke time, then we will use this "Chainless" truly global to indicate it is OK to call this without a chain context.</pre><strong>Reviewer</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>Reviewed</strong>: 12/15/2016, 3:07:32 PM<br><strong>Message</strong>: <pre>Patch Set 5:

(1 comment)</pre><strong>Reviewer</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>Reviewed</strong>: 12/15/2016, 3:08:17 PM<br><strong>Message</strong>: <pre>Patch Set 5:

(3 comments)</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 12/15/2016, 4:00:59 PM<br><strong>Message</strong>: <pre>Uploaded patch set 6.</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 12/15/2016, 4:02:10 PM<br><strong>Message</strong>: <pre>Patch Set 6:

Build Started https://jenkins.hyperledger.org/job/fabric-verify-x86_64/4197/</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 12/15/2016, 4:23:49 PM<br><strong>Message</strong>: <pre>Patch Set 6:

> (4 comments)
 > 
 > Probably missed that part, I was looking where do you call gossip
 > join channel to notify the gossip layer of the peer which has to
 > join the channel. Wasn't able to find it, can you please reference
 > me were are you doing that?

The JoinChannel is done in the core/peer.go.</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 12/15/2016, 4:38:30 PM<br><strong>Message</strong>: <pre>Patch Set 6: Verified+1

Build Successful 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/4197/ : SUCCESS</pre><strong>Reviewer</strong>: Artem Barger - bartem@il.ibm.com<br><strong>Reviewed</strong>: 12/15/2016, 4:55:15 PM<br><strong>Message</strong>: <pre>Patch Set 6:

(3 comments)</pre><strong>Reviewer</strong>: Artem Barger - bartem@il.ibm.com<br><strong>Reviewed</strong>: 12/15/2016, 5:01:54 PM<br><strong>Message</strong>: <pre>Patch Set 6: Code-Review+1</pre><strong>Reviewer</strong>: Gari Singh - gari.r.singh@gmail.com<br><strong>Reviewed</strong>: 12/15/2016, 5:24:26 PM<br><strong>Message</strong>: <pre>Patch Set 6:

it just seems to me there has got to be a better way to get these end to end things working in a more incremental fashion.  Not sure I have the answer, but seems we remove one static / hard-coded / dummy value and then end up adding another for the next stage</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 12/15/2016, 6:23:38 PM<br><strong>Message</strong>: <pre>Uploaded patch set 7.</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 12/15/2016, 6:27:03 PM<br><strong>Message</strong>: <pre>Patch Set 7:

Build Started https://jenkins.hyperledger.org/job/fabric-verify-x86_64/4210/</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 12/15/2016, 6:42:34 PM<br><strong>Message</strong>: <pre>Patch Set 6:

> it just seems to me there has got to be a better way to get these
 > end to end things working in a more incremental fashion.  Not sure
 > I have the answer, but seems we remove one static / hard-coded /
 > dummy value and then end up adding another for the next stage

The hardcoding is reducing Gari. For example, no more special "ledger manager" code. The main hardcoding now is TEST_CHAINID and the assumption that it exists in the orderer.  Did you have any other in mind which we can / should do away with ?</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 12/15/2016, 6:56:45 PM<br><strong>Message</strong>: <pre>Patch Set 7: Verified+1

Build Successful 

https://jenkins.hyperledger.org/job/fabric-verify-x86_64/4210/ : SUCCESS</pre><strong>Reviewer</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>Reviewed</strong>: 12/15/2016, 11:33:14 PM<br><strong>Message</strong>: <pre>Patch Set 7: Code-Review+2</pre><strong>Reviewer</strong>: Gari Singh - gari.r.singh@gmail.com<br><strong>Reviewed</strong>: 12/16/2016, 5:58:16 AM<br><strong>Message</strong>: <pre>Patch Set 7: Code-Review+2

let's keep this moving</pre><strong>Reviewer</strong>: Gerrit Code Review - gerrit@hyperledger.org<br><strong>Reviewed</strong>: 12/16/2016, 8:22:19 AM<br><strong>Message</strong>: <pre>Change has been successfully merged by Christopher Ferris</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 12/16/2016, 8:23:35 AM<br><strong>Message</strong>: <pre>Patch Set 7:

Build Started https://jenkins.hyperledger.org/job/fabric-merge-x86_64/596/</pre><strong>Reviewer</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Reviewed</strong>: 12/16/2016, 8:28:12 AM<br><strong>Message</strong>: <pre>Patch Set 7:

Thanks for the reviews.. some good ones.

Just wanted to note that we will also propose a model where common chaincode is not instantiated for each chain but the running instance is shared. The chain context will just be switched on each invoke. This will simplify and scale. With that model, the "chainless" should go away as we won't need it to decide instantiation.</pre><strong>Reviewer</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Reviewed</strong>: 12/16/2016, 8:35:29 AM<br><strong>Message</strong>: <pre>Patch Set 7:

Build Failed 

https://jenkins.hyperledger.org/job/fabric-merge-x86_64/596/ : FAILURE</pre><h1>PatchSets</h1><h3>PatchSet Number: 1</h3><blockquote><strong>Type</strong>: REWORK<br><strong>Author</strong>: Srinivasan Muralidharan - muralisr@us.ibm.com<br><strong>Uploader</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Created</strong>: 12/13/2016, 12:59:16 AM<br><strong>UnmergedRevision</strong>: [9e65ec9cc8ef891cbde61236f5f3573fb8685a36](https://github.com/hyperledger-gerrit-archive/fabric/commit/9e65ec9cc8ef891cbde61236f5f3573fb8685a36)<br><br><strong>Approver</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Approved</strong>: 12/13/2016, 1:22:56 AM<br><strong>Type</strong>: Verified<br><strong>Value</strong>: -1<br><br></blockquote><h3>PatchSet Number: 2</h3><blockquote><strong>Type</strong>: REWORK<br><strong>Author</strong>: Srinivasan Muralidharan - muralisr@us.ibm.com<br><strong>Uploader</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Created</strong>: 12/13/2016, 7:51:02 AM<br><strong>UnmergedRevision</strong>: [52e99d0f434939030b03bf54db0bcc93873cd7b8](https://github.com/hyperledger-gerrit-archive/fabric/commit/52e99d0f434939030b03bf54db0bcc93873cd7b8)<br><br><strong>Approver</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Approved</strong>: 12/13/2016, 8:27:58 AM<br><strong>Type</strong>: Verified<br><strong>Value</strong>: -1<br><br></blockquote><h3>PatchSet Number: 3</h3><blockquote><strong>Type</strong>: REWORK<br><strong>Author</strong>: Srinivasan Muralidharan - muralisr@us.ibm.com<br><strong>Uploader</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Created</strong>: 12/13/2016, 7:52:28 AM<br><strong>UnmergedRevision</strong>: [4726ce089dd5698caeb135e58f36985e330c7047](https://github.com/hyperledger-gerrit-archive/fabric/commit/4726ce089dd5698caeb135e58f36985e330c7047)<br><br><strong>Approver</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Approved</strong>: 12/13/2016, 8:20:50 AM<br><strong>Type</strong>: Verified<br><strong>Value</strong>: -1<br><br></blockquote><h3>PatchSet Number: 4</h3><blockquote><strong>Type</strong>: REWORK<br><strong>Author</strong>: Srinivasan Muralidharan - muralisr@us.ibm.com<br><strong>Uploader</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Created</strong>: 12/13/2016, 9:07:23 PM<br><strong>UnmergedRevision</strong>: [3f483314c5f3ce6ca158e8ef09b967c983f8caf4](https://github.com/hyperledger-gerrit-archive/fabric/commit/3f483314c5f3ce6ca158e8ef09b967c983f8caf4)<br><br><strong>Approver</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Approved</strong>: 12/13/2016, 9:44:43 PM<br><strong>Type</strong>: Verified<br><strong>Value</strong>: 1<br><br><strong>Approver</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>Approved</strong>: 12/13/2016, 11:40:40 PM<br><strong>Type</strong>: Code-Review<br><strong>Value</strong>: -1<br><br><h2>Comments</h2><strong>Commenter</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>CommentLine</strong>: [core/chaincode/importsysccs.go#L29](https://github.com/hyperledger-gerrit-archive/fabric/blob/3f483314c5f3ce6ca158e8ef09b967c983f8caf4/core/chaincode/importsysccs.go#L29)<br><strong>Comment</strong>: <pre>We probably want to discuss more about ths attr. I know what you mean, but I would consider that the app invokes cscc with a chain, which is being created, but the chain ID exists, so do we still need this attr?</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [core/chaincode/importsysccs.go#L29](https://github.com/hyperledger-gerrit-archive/fabric/blob/3f483314c5f3ce6ca158e8ef09b967c983f8caf4/core/chaincode/importsysccs.go#L29)<br><strong>Comment</strong>: <pre>Well, "chainID" exists but the underpinnings for it does not - the ledger for instance. It is good to make quite explicit that this chaincode cannot do any chain (ledger) operations.

Also, CSCC is a singleton chain that is NOT run on all chains. "Chainless" suggests that.

We *could* make a special case for CSCC and get rid of "Chainless" but having this gives us the flexibility to add more such system chaincodes.</pre><strong>Commenter</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>CommentLine</strong>: [core/endorser/endorser.go#L62](https://github.com/hyperledger-gerrit-archive/fabric/blob/3f483314c5f3ce6ca158e8ef09b967c983f8caf4/core/endorser/endorser.go#L62)<br><strong>Comment</strong>: <pre>We should get ledger through peer.GetLedger(cid)</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [core/endorser/endorser.go#L62](https://github.com/hyperledger-gerrit-archive/fabric/blob/3f483314c5f3ce6ca158e8ef09b967c983f8caf4/core/endorser/endorser.go#L62)<br><strong>Comment</strong>: <pre>Good idea, let me look into that (perhaps time to get rid of kv_ledgers.go ...)</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [core/endorser/endorser.go#L62](https://github.com/hyperledger-gerrit-archive/fabric/blob/3f483314c5f3ce6ca158e8ef09b967c983f8caf4/core/endorser/endorser.go#L62)<br><strong>Comment</strong>: <pre>Done</pre><strong>Commenter</strong>: Alessandro Sorniotti - ale.linux@sopit.net<br><strong>CommentLine</strong>: [core/endorser/endorser.go#L274](https://github.com/hyperledger-gerrit-archive/fabric/blob/3f483314c5f3ce6ca158e8ef09b967c983f8caf4/core/endorser/endorser.go#L274)<br><strong>Comment</strong>: <pre>You may want to determine whether this proposal is chainless right at the beginning of this function so that you can do a different type of proposal validation (see my other comment in msgvalidation.go).</pre><strong>Commenter</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>CommentLine</strong>: [core/ledger/kvledger/kv_ledgers.go#L0](https://github.com/hyperledger-gerrit-archive/fabric/blob/3f483314c5f3ce6ca158e8ef09b967c983f8caf4/core/ledger/kvledger/kv_ledgers.go#L0)<br><strong>Comment</strong>: <pre>We should remove this code now and replace these call with those in peer.go; otherwise we would not be able to manage multichain.</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [core/ledger/kvledger/kv_ledgers.go#L0](https://github.com/hyperledger-gerrit-archive/fabric/blob/3f483314c5f3ce6ca158e8ef09b967c983f8caf4/core/ledger/kvledger/kv_ledgers.go#L0)<br><strong>Comment</strong>: <pre>Right. Let me look into this. If this creates ripples might (I'm thinking for the normal use case of peer starting up with TEST_CHAINID) we could remove it in another CR.</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [core/ledger/kvledger/kv_ledgers.go#L0](https://github.com/hyperledger-gerrit-archive/fabric/blob/3f483314c5f3ce6ca158e8ef09b967c983f8caf4/core/ledger/kvledger/kv_ledgers.go#L0)<br><strong>Comment</strong>: <pre>kv_ledgers.go and kv_ledgers_test.go have been deleted. Not sure why gerritt still shows hem as hanging around</pre><strong>Commenter</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>CommentLine</strong>: [core/peer/msgvalidation.go#L116](https://github.com/hyperledger-gerrit-archive/fabric/blob/3f483314c5f3ce6ca158e8ef09b967c983f8caf4/core/peer/msgvalidation.go#L116)<br><strong>Comment</strong>: <pre>I think we should do this via peer.go as it manages mspmgr per chain.</pre><strong>Commenter</strong>: Alessandro Sorniotti - ale.linux@sopit.net<br><strong>CommentLine</strong>: [core/peer/msgvalidation.go#L120](https://github.com/hyperledger-gerrit-archive/fabric/blob/3f483314c5f3ce6ca158e8ef09b967c983f8caf4/core/peer/msgvalidation.go#L120)<br><strong>Comment</strong>: <pre>Please have a look at https://gerrit.hyperledger.org/r/#/c/3285/. I've reorganized the proposal validation code and added ValidateProposalMessageForChain and ValidateProposalMessageForChainlessCC.</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [core/peer/msgvalidation.go#L120](https://github.com/hyperledger-gerrit-archive/fabric/blob/3f483314c5f3ce6ca158e8ef09b967c983f8caf4/core/peer/msgvalidation.go#L120)<br><strong>Comment</strong>: <pre>I looked at that Alessandro but it won't work the way you have it (see the comment on that CR).</pre><strong>Commenter</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>CommentLine</strong>: [core/peer/msp/mgmt.go#L82](https://github.com/hyperledger-gerrit-archive/fabric/blob/3f483314c5f3ce6ca158e8ef09b967c983f8caf4/core/peer/msp/mgmt.go#L82)<br><strong>Comment</strong>: <pre>this code shouldn't be here, and the function GetManagerForChain is on its way out.  These calls should be on peer.go</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [core/peer/msp/mgmt.go#L82](https://github.com/hyperledger-gerrit-archive/fabric/blob/3f483314c5f3ce6ca158e8ef09b967c983f8caf4/core/peer/msp/mgmt.go#L82)<br><strong>Comment</strong>: <pre>I can move this func to peer.go and use mspmgr from chains maintained there.</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [core/peer/msp/mgmt.go#L82](https://github.com/hyperledger-gerrit-archive/fabric/blob/3f483314c5f3ce6ca158e8ef09b967c983f8caf4/core/peer/msp/mgmt.go#L82)<br><strong>Comment</strong>: <pre>As peer.go does not initialize its MSPManger (still nil) will let this code be around.</pre></blockquote><h3>PatchSet Number: 5</h3><blockquote><strong>Type</strong>: REWORK<br><strong>Author</strong>: Srinivasan Muralidharan - muralisr@us.ibm.com<br><strong>Uploader</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Created</strong>: 12/15/2016, 2:06:11 AM<br><strong>UnmergedRevision</strong>: [268f5e09c6ce8a980eecc5a5724af69d9a79936d](https://github.com/hyperledger-gerrit-archive/fabric/commit/268f5e09c6ce8a980eecc5a5724af69d9a79936d)<br><br><strong>Approver</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Approved</strong>: 12/15/2016, 2:53:13 AM<br><strong>Type</strong>: Verified<br><strong>Value</strong>: 1<br><br><strong>Approver</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>Approved</strong>: 12/15/2016, 9:51:01 AM<br><strong>Type</strong>: Code-Review<br><strong>Value</strong>: 1<br><br><h2>Comments</h2><strong>Commenter</strong>: Artem Barger - bartem@il.ibm.com<br><strong>CommentLine</strong>: [core/chaincode/handler.go#L521](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/handler.go#L521)<br><strong>Comment</strong>: <pre>It seems that those lines repeated, probably worth extracting into function or something.</pre><strong>Commenter</strong>: Christopher Ferris - chris.ferris@gmail.com<br><strong>CommentLine</strong>: [core/chaincode/handler.go#L521](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/handler.go#L521)<br><strong>Comment</strong>: <pre>+1</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [core/chaincode/handler.go#L521](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/handler.go#L521)<br><strong>Comment</strong>: <pre>yes. I should have done that... subtle differences made it seem iffy but you are right.</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [core/chaincode/importsysccs.go#L28](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/importsysccs.go#L28)<br><strong>Comment</strong>: <pre>Once upon a time we had discussed having the CSCC translate the config into ledger-storable stuff, is this no longer the case?</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [core/chaincode/importsysccs.go#L28](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/importsysccs.go#L28)<br><strong>Comment</strong>: <pre>If you mean along with Policy ? I think its still the case but outside scope of this work ... let me know if I misunderstood the question though.</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [core/chaincode/importsysccs.go#L28](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/importsysccs.go#L28)<br><strong>Comment</strong>: <pre>The code here explicitly states that the chainless CC stuff cannot write to the ledger.  It had been my impression that the CSCC would be translating the config stuff into data stored on the ledger, which seems like it would require writing to the ledger.  So these concepts seemed contradictory.</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [core/chaincode/importsysccs.go#L28](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/importsysccs.go#L28)<br><strong>Comment</strong>: <pre>Right, this code cannot do GetState/PutState on the chaincode API from the chaincode to access the ledger (as there is no chaincode context). That is what typical chaincodes do and the peer will trap those calls and stop them.
However, as this is a system chaincode and as config invoke knows the chain it operates on, it can get the ledger in the chaincode itself to do ledger operation.</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [core/chaincode/importsysccs.go#L28](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/importsysccs.go#L28)<br><strong>Comment</strong>: <pre>I see, makes sense.

Done</pre><strong>Commenter</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>CommentLine</strong>: [core/chaincode/importsysccs.go#L28](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/importsysccs.go#L28)<br><strong>Comment</strong>: <pre>no longer the case as the block has been signed and we can't modify it with write-set, so there's no read-write-set on config transactions</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [core/chaincode/sysccapi.go#L43](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/sysccapi.go#L43)<br><strong>Comment</strong>: <pre>If the cscc is global, how does that rectify this the comment in:

core/system_chaincode/cscc/peer_configer.go

which states:

// PeerConfiger implements the configuration handler for the peer. For every
// configuration transaction coming in from the ordering service, the
// committer calls this system chaincode to process the transaction.

It seems like CSCC must be per chain?</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [core/chaincode/sysccapi.go#L43](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/sysccapi.go#L43)<br><strong>Comment</strong>: <pre>Yes. The join function has to be "outside" of chains (as it creates a chain). The config functions has to have a chain context.

The easy way is to allow such singleton sys CCs access to ledger at commit time (they get the TX and chain context and can access the ledger directly). 

The more elegant way is to run "same" chaincodes only once but switch ledger context.  I'll be opening a JIRA for this in case we want to switch to this mode (its more scalable too). It'll also get rid of the "Chainless" attribute.

If you think this should be resolved before moving further, that's perfectly fine and we can discuss more.</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [core/chaincode/sysccapi.go#L43](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/sysccapi.go#L43)<br><strong>Comment</strong>: <pre>> Yes. The join function has to be "outside" of chains (as it creates a chain). The config functions has to have a chain context.

Makes sense

> The easy way is to allow such singleton sys CCs access to ledger at commit time (they get the TX and chain context and can access the ledger directly). 
>
> The more elegant way is to run "same" chaincodes only once but switch ledger context.  I'll be opening a JIRA for this in case we want to switch to this mode (its more scalable too). It'll also get rid of the "Chainless" attribute.


I'm not certain I follow, Is the second approach not a singleton? Intuitively, I would have assumed that each chain gets its own CSCC instance, but it sounds like this is not the case at all?</pre><strong>Commenter</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>CommentLine</strong>: [core/chaincode/sysccapi.go#L43](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/sysccapi.go#L43)<br><strong>Comment</strong>: <pre>There should be 1 instance (container) of chaincode per deployment, and every invocation on the chaincode has a context within which the chaincode operates.  That is, an instance of a chaincode can operate on multiple chains simultaneously.</pre><strong>Commenter</strong>: Artem Barger - bartem@il.ibm.com<br><strong>CommentLine</strong>: [core/chaincode/sysccapi.go#L94](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/sysccapi.go#L94)<br><strong>Comment</strong>: <pre>Not sure, whenever this is correct, but don't you use:

      chaincode.IsChainlessSysCC(chainID)</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [core/chaincode/sysccapi.go#L94](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/sysccapi.go#L94)<br><strong>Comment</strong>: <pre>A subtle difference... the method checks for name (so chaincode.IsChainlessSysCC(chaincodeName) ) where here we are asserting an empty chain ID can be assoicated only with a chainless syscc.</pre><strong>Commenter</strong>: Artem Barger - bartem@il.ibm.com<br><strong>CommentLine</strong>: [core/chaincode/sysccapi.go#L94](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/sysccapi.go#L94)<br><strong>Comment</strong>: <pre>I see, thanks.</pre><strong>Commenter</strong>: Artem Barger - bartem@il.ibm.com<br><strong>CommentLine</strong>: [core/chaincode/sysccapi.go#L108](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/sysccapi.go#L108)<br><strong>Comment</strong>: <pre>Is there a reason to use defer here? IMO it defers function call till entire function returns?</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [core/chaincode/sysccapi.go#L108](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/sysccapi.go#L108)<br><strong>Comment</strong>: <pre>Which is precisely what we want :-) call Done on function return to clean and close the txsim. The context contains the simulater and passed to callers to access if defined. Closed when exiting this method.</pre><strong>Commenter</strong>: Artem Barger - bartem@il.ibm.com<br><strong>CommentLine</strong>: [core/chaincode/sysccapi.go#L108](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/chaincode/sysccapi.go#L108)<br><strong>Comment</strong>: <pre>Ok.</pre><strong>Commenter</strong>: Alessandro Sorniotti - ale.linux@sopit.net<br><strong>CommentLine</strong>: [core/peer/msgvalidation.go#L120](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/peer/msgvalidation.go#L120)<br><strong>Comment</strong>: <pre>Please have a look at take 2 of https://gerrit.hyperledger.org/r/#/c/3285/ I've implemented proposal validation for chainless CC in a more elegant way as discussed on Slack</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [core/peer/msgvalidation.go#L120](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/peer/msgvalidation.go#L120)<br><strong>Comment</strong>: <pre>Thanks, Alessdandro. We can rebase or submit another  to use your CR  based on which gets in first.</pre><strong>Commenter</strong>: Artem Barger - bartem@il.ibm.com<br><strong>CommentLine</strong>: [core/peer/peer.go#L65](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/peer/peer.go#L65)<br><strong>Comment</strong>: <pre>IMO, all mock infrastructure should not be a part of public API.</pre><strong>Commenter</strong>: Christopher Ferris - chris.ferris@gmail.com<br><strong>CommentLine</strong>: [core/peer/peer.go#L65](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/peer/peer.go#L65)<br><strong>Comment</strong>: <pre>+1</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [core/peer/peer.go#L65](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/peer/peer.go#L65)<br><strong>Comment</strong>: <pre>Right, I felt queasy about this too.. but callers are in other packages. Would it be better to call it TestInitialize to make the intent clear this is for initializing the test environment ?</pre><strong>Commenter</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>CommentLine</strong>: [core/peer/peer.go#L65](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/peer/peer.go#L65)<br><strong>Comment</strong>: <pre>Sometime it's test-driven design :-)
Another way we could do would be to provide GetChains(), but I think that would be more dangerous.</pre><strong>Commenter</strong>: Artem Barger - bartem@il.ibm.com<br><strong>CommentLine</strong>: [core/peer/peer.go#L65](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/core/peer/peer.go#L65)<br><strong>Comment</strong>: <pre>Done</pre><strong>Commenter</strong>: Jason Yellick - jyellick@us.ibm.com<br><strong>CommentLine</strong>: [peer/node/start.go#L191](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/peer/node/start.go#L191)<br><strong>Comment</strong>: <pre>So we see this as creating a single Deliver service, then invoking Deliver multiple times, once per chain?</pre><strong>Commenter</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>CommentLine</strong>: [peer/node/start.go#L191](https://github.com/hyperledger-gerrit-archive/fabric/blob/268f5e09c6ce8a980eecc5a5724af69d9a79936d/peer/node/start.go#L191)<br><strong>Comment</strong>: <pre>The only purpose of this "if" section is to use the "peer node start" work using TEST_CHAINID without issuing a "peer node join...".   When join support is fully in, users would have to join to TEST_CHAINID (once) when testing and dev. Then this section can be removed along with noopssinglechain. What do you think ?</pre></blockquote><h3>PatchSet Number: 6</h3><blockquote><strong>Type</strong>: REWORK<br><strong>Author</strong>: Srinivasan Muralidharan - muralisr@us.ibm.com<br><strong>Uploader</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Created</strong>: 12/15/2016, 4:00:59 PM<br><strong>UnmergedRevision</strong>: [263c7e28fc8176cdcc00dd46c5bf697c81e15d5c](https://github.com/hyperledger-gerrit-archive/fabric/commit/263c7e28fc8176cdcc00dd46c5bf697c81e15d5c)<br><br><strong>Approver</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Approved</strong>: 12/15/2016, 4:38:30 PM<br><strong>Type</strong>: Verified<br><strong>Value</strong>: 1<br><br><strong>Approver</strong>: Artem Barger - bartem@il.ibm.com<br><strong>Approved</strong>: 12/15/2016, 5:01:54 PM<br><strong>Type</strong>: Code-Review<br><strong>Value</strong>: 1<br><br></blockquote><h3>PatchSet Number: 7</h3><blockquote><strong>Type</strong>: REWORK<br><strong>Author</strong>: Srinivasan Muralidharan - muralisr@us.ibm.com<br><strong>Uploader</strong>: Srinivasan Muralidharan - srinivasan.muralidharan99@gmail.com<br><strong>Created</strong>: 12/15/2016, 6:23:38 PM<br><strong>GitHubMergedRevision</strong>: [85b47e605751650fa13c87ef2fb475f3cf1b14bd](https://github.com/hyperledger-gerrit-archive/fabric/commit/85b47e605751650fa13c87ef2fb475f3cf1b14bd)<br><br><strong>MergedBy</strong>: Christopher Ferris<br><strong>Merged</strong>: 12/16/2016, 8:22:19 AM<br><br><strong>Approver</strong>: Hyperledger Jobbuilder - jobbuilder@jenkins.hyperledger.org<br><strong>Approved</strong>: 12/15/2016, 6:56:45 PM<br><strong>Type</strong>: Verified<br><strong>Value</strong>: 1<br><br><strong>Approver</strong>: Binh Nguyen - binh1010010110@gmail.com<br><strong>Approved</strong>: 12/15/2016, 11:33:14 PM<br><strong>Type</strong>: Code-Review<br><strong>Value</strong>: 1<br><br><strong>Approver</strong>: Gari Singh - gari.r.singh@gmail.com<br><strong>Approved</strong>: 12/16/2016, 5:58:16 AM<br><strong>Type</strong>: Code-Review<br><strong>Value</strong>: 1<br><br></blockquote>